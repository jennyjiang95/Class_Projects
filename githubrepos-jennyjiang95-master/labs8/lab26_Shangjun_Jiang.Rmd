---
title: "lab25"
name: "Shangjun Jiang"
date: "July 26, 2016"
output: html_document
---

## plot
```{r}
plotGrid = 
function(x)
{
  image(x, col = c('white', 'red', 'blue'), axe = FALSE)
}

```

moveCars(30,30,0.5,10)

## 1 red cars: east, right side
## 2 blue cars: north, top/up.
## 0 no cars

## odd number step: red east
## even number step: blue up

```{r}
m <- matrix(c(2,0,2,2,2,0,1,1,0), nrow = 3, ncol = 3, byrow = T)
n <- matrix(c(2,2,0,1,0,0,0,1,0), nrow = 3, ncol = 3, byrow = T)
n[1,]
m
# row, column
colnames(m) <- letters[1:3]
m[,c(3,1,2)]
m[,c(2,3,1)]

```


Write a function called `moveCars()` that moves the system one full step; that is, the function should move the red cars east once and the blue cars north once, with red cars going first.

Your function should take the following inputs:
`m`: a matrix

Your function should return a list containing two elements:
`m`: an updated matrix
`not_gridlocked`: a logical value that should be TRUE if the system changed and FALSE if not

```{r}
checkRed <- function(checkPos, whereToMove, colNum, n)
{
    checkNum = checkPos - colNum
    checkNum[checkNum < 0] = checkNum[checkNum < 0] + n
    if(checkNum %in% as.numeric(names(whereToMove)))
    {
        
        whereToMove[as.character(checkNum)] =TRUE
        checkRed(checkNum, whereToMove, colNum, n)
    }
    else return(whereToMove)
}

checkBlue <- function(checkPos, whereToMove, colNum)
{
  checkNum = checkPos - 1
  if(ceiling(checkNum/colNum) < ceiling(checkPos/colNum))
  {
    checkNum = checkNum + colNum
  }
  if( (checkNum) %in% as.numeric(names(whereToMove)))
  {
    
    whereToMove[as.character(checkNum)] = TRUE
    checkBlue(checkNum, whereToMove,colNum)
  }
  else return(whereToMove)
}

redCarMove = function(currentRedPos, currentBluePos, colNum, rowNum, n)
{
  movetry = (currentRedPos + colNum) 
  movetry[movetry > n] = movetry[movetry > n] - n
  whereToMove = movetry %in% currentBluePos
  names(whereToMove) = currentRedPos
  checkPoints = as.numeric(names(whereToMove[whereToMove == TRUE]))
  if(length(checkPoints))
  {
      whereToMove <- rowSums(sapply(checkPoints, checkRed, whereToMove, colNum, n)) != 0
  }
  move = (currentRedPos[!whereToMove] + colNum)
  move[move > n] = move[move > n] - n  
  currentRedPos[!whereToMove] = move
  grid = integer(n)
  grid[currentRedPos] = 1
  grid[currentBluePos] = 2
  myGrid = matrix(grid, nrow = rowNum, ncol = colNum, byrow = TRUE)
  plotGrid(myGrid)
  return(list(currentRedPos = currentRedPos, currentBluePos = currentBluePos))
}


blueCarMove = function(currentBluePos, currentRedPos, colNum, rowNum, n)
{
  bmovetry = (currentBluePos + 1 - 
                (ceiling((currentBluePos + 1) / colNum) - 
                   ceiling(currentBluePos / colNum)) * colNum) 
  
  bwhereToMove = bmovetry %in% currentRedPos
  names(bwhereToMove) = currentBluePos
  checkPoints = as.numeric(names(bwhereToMove[bwhereToMove == TRUE]))
  if(length(checkPoints))
  {
    bwhereToMove <- rowSums(sapply(checkPoints, checkBlue, bwhereToMove,colNum)) != 0
  }
  
  move = (currentBluePos[!bwhereToMove] + 1 -
            (ceiling((currentBluePos[!bwhereToMove] + 1) / colNum) - 
               ceiling(currentBluePos[!bwhereToMove] / colNum)) * colNum)
  
  
  currentBluePos[!bwhereToMove] = move
  grid = integer(rowNum * colNum)
  grid[currentRedPos] = 1
  grid[currentBluePos] = 2
  bmyGrid = matrix(grid, nrow = rowNum, ncol = colNum, byrow = TRUE)
  plotGrid(bmyGrid)
  return(list(currentRedPos = currentRedPos, currentBluePos = currentBluePos))
}



moveCars =
function(rowNum = 5,colNum = 5, rho = 0.3, steps = 3)
{
  n = rowNum * colNum
  test = createGrid(rowNum = rowNum,colNum = colNum, rho = rho)
  currentRedPos = test$rc
  currentBluePos = test$bc
  
  for(i in 1: steps)
  {
    #move red cars
    redRun = redCarMove(currentRedPos, currentBluePos, colNum, rowNum, n)
    currentRedPos = redRun$currentRedPos
    currentBluePos = redRun$currentBluePos
    #move blue cars
    blueRun = blueCarMove(currentBluePos, currentRedPos, colNum, rowNum, n)
    currentRedPos = blueRun$currentRedPos
    currentBluePos = blueRun$currentBluePos
  }  
}



```

moveCars(5,5,0.5,20)

Check:
```{r, eval = F}
m <- matrix(c(1,0,0,0,2,1,2,0,0,2,0,1,1,0,1,2,0,1,2,1,0,0,1,1,2), nrow = 5, ncol = 5, byrow = T)
identical(moveCars(m), list(matrix(c(0,1,0,0,2,1,2,0,0,2,1,1,0,1,0,2,0,1,2,1,0,0,1,1,2), nrow = 5, ncol = 5, byrow = T), TRUE))

m <-  matrix(c(0,1,0,2,1), nrow = 1, ncol = 5, byrow = T)
identical(moveCars(m), list(matrix(c(1,0,1,2,0), nrow = 1, ncol = 5, byrow = T), TRUE))

m <- matrix(c(2,0,1,2,0), nrow = 5, ncol = 1, byrow = T)
identical(moveCars(m), list(matrix(c(0,0,1,2,2), nrow = 5, ncol = 1, byrow = T), TRUE))
```

Now write a function called `initGrid()` that randomizes the initial system.

Your function should take the following inputs:
`r`: number of rows in the matrix
`c`: number of columns in the matrix
`d`: density of the grid 

Your function should return the following:
`m`: an rxc matrix with entries 0 (no cars), 1 (red cars), or 2 (blue cars)

```{r}

initGrid = 
function(rowNum = 10, colNum = 6, rho = 0.3)
{
  grid = integer(rowNum * colNum)
  blueNum = redNum = rowNum * colNum * rho / 2
  set.seed(1000)
  pos = sample(x = rowNum * colNum, size = blueNum + redNum, replace = FALSE)
  blueCars = pos[1:blueNum]
  redCars = pos[-(1:blueNum)]
  grid[redCars] = 1
  grid[blueCars] = 2
  myGrid = matrix(grid, nrow = rowNum, ncol = colNum, byrow = TRUE)
  box()
  return(list(grid = myGrid, bc = blueCars, rc = redCars))
}

# plotGrid(myGrid)
#initGrid(3,3,0.5)

```






