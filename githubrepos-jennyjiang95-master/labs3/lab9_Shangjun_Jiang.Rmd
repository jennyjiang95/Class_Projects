---
title: "lab9"
author: "Shangjun Jiang"
date: "June 21, 2016"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Libraries

The following libraries are allowed for this lab.  They have already been loaded in this document.

* `stringr`
* `dplyr`
* `tidyr`

```{r, include = FALSE}
library(stringr)
library(dplyr)
library(tidyr)
```


## Our Glorious Foundation

The vector pioneers has already been created for you
```{r}
pioneers <- c("GAUSS:1777", "BAYES:1702", "NEYMAN:1894", "LAPLACE:1749")
```

1.  Review: Split the names from the birth years using `str_split`, discarding the colon.  Assign the output to the variable `split_pioneers`.
```{r}
# Your code
split_pioneers <- str_split (pioneers, ":")
split_pioneers
```

2.  What class is the output object?
```{r}
# Your code
class (split_pioneers)
```

3.  Without writing a loop, convert the strings to first-letter uppercase only.  Hint: `str_to_upper` is actually part of a family of functions.  Getting the documentation on it will reveal other functions like it.  Assign the output to the variable `statisticians`
```{r}
# Your code
?str_to_upper
lower <- str_to_lower (pioneers)
str_c ((str_split (lower, ":")[1]), collapse ="")
(lapply (split_pioneers, str_to_title))

statisticians<- lapply(split_pioneers, str_to_title)

```

4.  Try running `rbind` on statisticians.  What happens?
```{r}
# Your code
rbind (statisticians)
```
It creates a bizarre 1x4 matrix with vector elements.

5.  Using `do.call`, construct an `rbind` call that will turn the list into a matrix, `pioneers_df`
```{r}
# Your code
#lapply returns a list.
statisticians<- lapply(split_pioneers, str_to_title)
class (statisticians)
do.call(rbind, statisticians)
pioneers_df <-do.call(rbind, statisticians)
```

6.  Review: Convert the matrix into a data frame and name the columns `name` and `byear`.  Hint: `as...`
```{r}
# Your code
dfpionners <- data.frame (pioneers_df)
colnames(dfpionners) <- c("name", "byear")
```

7.  Review: Convert the column types of `name` and `byear` to character and integer, respectively.  Hint: Subset and `as...` 
```{r}
# Your code
dfpionners$name <- as.character(dfpionners$name)
dfpionners$byear<- as.numeric(dfpionners$byear)
```

## Narcotics

The `sleep` dataset (built into R---no need to load anything) shows the effect of soporific (increases in sleep) drugs as compared to a control group.  There are two drugs represented in the data, as denoted by the group number.  The ID number is unique to each patient.

1.  Use `tapply` to find the average change in sleep hours for each of the drugs.
```{r}
# Your code
tapply(sleep$extra, sleep$group, mean)
with (sleep, tapply(extra, group, mean))
```

2.  Use `lapply` and an anonymous function to split the data frame into 10 2x3 sub-data frames grouped by ID.  Assign the output to `split_sleep`.  This is just practice thinking about `lapply` since you could actually just use this call in practice:
```{r}
split(sleep, sleep$ID)
```

Hint: The first argument of `lapply` can be `1:10`.
```{r}
# Your code
split_sleep <- lapply (1:10, function(x) sleep[sleep$ID == x, ])
lapply (1:10, function(x) {with(sleep, ID == x)})


split_sleep
```

3.  Use `vapply` on `split_sleep` to calculate the difference in extra sleep (group 2 - group 1) for each patient.  Hint: You can be a little fancy here and use `with` as your `FUN`.  Remember to give `vapply` a suitable template vector.
```{r}
# Your code
str(sleep)
vapply(1:10, function(x) {with(split_sleep[[x]], extra[group== 2] - extra[group ==1])}, numeric(1))

vapply(split_sleep, with, numeric(1), extra[group==2] - extra[group==1])

vapply(split_sleep, function(x) {with(x, extra[group== 2] - extra[group ==1])}, numeric(1))

?vapply


```








## Look Me in the Iris

Iris is a rather famous data set introduced by Ronald Fisher in his paper _The use of multiple measurements in taxonomic problems_ as an example of classification by dividing the data using (hyper)-planes.  It is already pre-loaded into `R` under `iris` (no package needed) and is often used as an example dataset in documentation.  I suggest inspecting the data set before continuing.

Use the data wrangling verbs of `dplyr` in conjunction with the piping operator `%>%` to do the following tasks.  Your output should be data frames assigned to the names in bold.

1.  Get only the sepal and petal length columns of the data frame.  __iris_len__
```{r}
# Your code
str(iris)
iris_len <- select (iris, Sepal.Length, Petal.Length)
iris_len
```
2.  Get every column of the data frame besides Petal length and width.  Do not call on the other three columns by their names.  __no_petal__
```{r}
# Your code
no_petal <- select (iris, -c (Sepal.Length, Petal.Length))
no_petal
```
3.  Get only the species column, renaming it `species_name`.  __species__
```{r}
# Your code
species <- select (iris, species_name = Species)
species
```
4.  Create a column called `length_sum` that contains the sum of the petal and sepal lengths.  __add_length__
```{r}
# Your code
add_length <- mutate (iris, length_sum = Sepal.Length+ Petal.Length)
add_length
```
5.  Get only the rows of the data frame where the species is `setosa`. __only_setosa__
```{r}
# Your code
only_setosa <- filter (iris, species == "setosa")
only_setosa
```
6.  Get only the rows of the data frame where the species name contains exactly 4 vowels and the sum of the sepal length and width is less than 8.  __nonsense_filter__
```{r}
# Your code
nonsense_filter <- filter (iris, Sepal.Length + Sepal.Width <8,str_detect (Species,"^([^aeiou]*[aeiou]){4}[^aeiou]*$"))
nonsense_filter
filter (iris, str_detect (iris$Species,"^([^aeiou]*[aeiou]){4}[^aeiou]*$"))

```
7.  Get the average sepal width `avg_sw` and average sepal length `avg_sl` for each of the 3 species.  __sepal_avg_by_species__
```{r}
# Your code
sepal_avg_by_species <- 
  iris %>% 
  group_by (Species) %>% 
   summarise(avg_sw = mean(Sepal.Width),
            avg_sl = mean(Sepal.Length))
sepal_avg_by_species

```
8.  Overwrite the `Sepal.Width` column so that it reads `"wide"` if the width is greater than 3 and `"narrow"` otherwise.  Do the same for `Sepal.Length` except the threshold is 5.5 and the replacement is `"long"` and `"short"`.  The `ifelse` command might be useful.  __factorized__
```{r}
# Your code
factorized <- iris %>% 
  mutate (Sepal.Width = ifelse (Sepal.Width> 3, "wide", "narrow"),
          Sepal.Length = ifelse (Sepal.Length> 5.5, "long", "short"))
factorized

```
9.  Count how many of each wide-long, wide-short, narrow-long, and narrow-short pairs there are.  Hint: `group_by` followed by `tally` or `summarise`.  __sepal_counts__
```{r}
# Your code
sepal_counts <- factorized %>% 
  group_by(Sepal.Length, Sepal.Width) %>% 
  summarise(n())

sepal_counts <- factorized %>% 
  group_by(Sepal.Length, Sepal.Width) %>% 
  summarize()
sepal_counts

?tally

a<- c(strsplit("hello",""))
str_c(a,collapse="")

do.call(str_c,c(a,collapse=""))

```



```{r}

str(sleep)
str(split_sleep)

vapply(split_sleep,split_sleep$extra[group==2]-split_sleep$extra[group==2] ,numeric(1))

vapply(split_sleep, with, numeric(1), extra[group==2] - extra[group==1])


Spooky <- function(n) {
  for (i in 1:n) {
    print(str_c(i, "spooky", i + 2, "me"))
  }
}
Spooky(3)

vapply(1:3, function(i) str_c(i,"spooky",i+2,"me"), character(1))

?sample

sample(1:2,1,replace=T,prob=c(0.1,0.9))

  conversions <- list(
    Celsius = c(   -32,   5/9,   0),
    Kelvin  = c(459.67,   5/9,   0),
    Rankine = c(459.67,     1,   0),
    Delisle = c(   212,  -5/6,   0),
    Newton  = c(   -32, 11/60,   0),
    Reamur  = c(   -32,   4/9,   0),
    Romer   = c(   -32,  7/24, 7.5))

conversions[[1]][1]

paste("The", "1", "temperature system is not supported.")

?regex

vowels<-c("a","e","i","o","u")
leter<-"dwafieorhfiuarofghiuavfnjadklR"
vc<-str_count(leter,vowels)
names(vc)<-vowels
vc
names(vc)<-NULL
vc

?sd

str(tents)

which(tents$price > 300)
      
      $ brand == "big-agnes")



scored <- c(14, 14, 9, 14, 28, 13, 13, 24, 17, 6, 24, 0, 24, 13, 26, 14)
against <- c(19, 30, 16, 38, 31, 24, 23, 30, 41, 13, 20, 52, 13, 31, 24, 47)

scored[seq(2,6,2)]

seq(2,10,2)

sum(scored > 20)
scored>20
?seq


sort(table(flights$tailnum[flights$carrier == "AA"]))


states <- rownames(USArrests)

sum(str_detect(states, "[iI]"))

str_subset(states, "([^iI]*[iI]){2,}")

str_subset(states, "^([^aeiou]*[aeiou]){5}[^aeiou]*$")
str_subset(states, "([^aeiou]*[aeiou]){5}")

regex("^([^aeiou]*[aeiou]){5}[^aeiou]*$", ignore_case = TRUE)

?regex
str_sub("hellomylove",seq(1,11,3),seq(3,11,3))

str_length("hellomylove")

str_split("hellomylove", "")[[1]]

Sandwich2 <- function(n) {
  str_detect(n, "([0-9])[0-9]\\1")
}

Sandwich2(122)


counts <- str_length(states)
tapply(states, counts, c)


```









